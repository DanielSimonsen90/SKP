import ComponentEventEmitter from './Events/ComponentEventEmitter';
import { Child, ComponentCollection } from '../Collection/ComponentCollection'
import IComponent from './IComponent';
import DOMTokenArray from '../Collection/DOMTokenArray';
import NamedNodeArray from '../Collection/NamedNodeArray';

export { IComponent, Child }

export default class Component<
    StateType extends {} = {}, 
    PropsType extends {} = {}
> extends ComponentEventEmitter implements IComponent {
    constructor(id: string, props: PropsType, children?: Array<Child>, options?: IComponent) {
        super();

        this._id = options?.id || id;
        this._props = { ...props, ...options?.props };
        this.children = new ComponentCollection(...new Set([...children, ...options.children]));
        const { attributes, classes } = options;
        this.attributes = new NamedNodeArray(...attributes);
        this.classes = new DOMTokenArray(...classes);

        this._setState(props, 'props')
            ._setState(this.setState(), 'state');

        this._setEvents().emit('_preRender');
    }

    private _id: string;
    public get id() {
        return this._id;
    }

    private _props: PropsType;
    public props: PropsType;
    public children: ComponentCollection;
    public get tagName(): keyof HTMLElementTagNameMap {
        const renderLines = this.render().split('\n');
        const lastLine = renderLines[renderLines.length - 1];
        return lastLine.substring(2, lastLine.length - 1).toUpperCase() as keyof HTMLElementTagNameMap;
    }
    public attributes: NamedNodeArray;
    public classes: DOMTokenArray;

    public preRender(): this {
        return this;
    }
    public render(): string {
        return (
            `<${this.tagName} ${Object.keys(this.props).map(p => `${p}="${this.props[p]}"`).join(' ')}>` +
                this.children.render().join('\n\t') +
            `</${this.tagName}`
        )
    }
    public rendered(): this {
        return this;
    }
    public propUpdate(currentValue: any, updatedValue: any): this {
        return this;
    }

    private _state: StateType;
    public get state() {
        return Object.freeze(this._state);
    }
    protected setState(): StateType {
        return {} as StateType;
    }
    private _setState(state: PropsType | StateType, stateName: string) {
        const that = this;
        Object.keys(state).forEach(prop => {
            const _state = `_${stateName}`;
            Object.defineProperty(this, _state, {
                value: state[prop],
                get() { return that[_state][prop]; },
                set(value) { 
                    that.componentEmit('propUpdate', that[stateName][prop], value);
                    return that[_state][prop] = value; 
                }
            })
        });
        return that;
    }

    private _preRender(): string {
        this.componentEmit('preRender', this);
        const render = this.emit<string>('_render', this.props)[0];
        document.getElementById(this.id).innerHTML = render;
        return render;
    }
    private _render(): string {
        const html = this.componentEmit('render', this)[0];
        const backup = `<div>Hi there! ${this.id ? `My name is ${this.id}!` : `I don't have a name, but`} I'm a div!</div>`;
        this.emit('_rendered');
        return this.tagName ? html : backup;
    }
    private _propUpdate(current: any, updated: any) {
        const { props } = this.componentEmit('propUpdate', current, updated)[0];
        this.emit('_preRender', props);
    }

    private _setEvents(): this {
        return this
            .on('_render', this._render)
            .on('propUpdate', this._propUpdate)
            .componentOn('_preRender', this._preRender)
            .componentOn('preRender', this.preRender)
            .componentOn('render', this.render)
            .componentOn('rendered', this.rendered)
            .componentOn('propUpdate', this.propUpdate)
    }
}